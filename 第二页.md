
#变量提升
看如下这段代码
```
a=2;
var a;
console.log(a)
```
输出回事什么呢？答案是**2**.在看一个代码:
```
console.log(a);
var a=2;
```
输出是2吗？这个时候输出是**undefined**.这是因为var a=2.这一句代码其实 是2个步骤.第一步是申明var a;第二步是赋值a=2;
而申明的这个过程会在编译过程就执行了。什么意思呢？简单的说在作用域范围内，不管我再那申明变量，它最后实际上就是在作用域范围的最顶端申明的。而赋值语句的代码则停留在原地，等待代码执行!以上两个例子实际上就是这样的：
```
var a;//跑到第一行来了
a=2;
console.log(a)
```
```
var a;
console.log(a)
a=2;//原本var a=2;中的var a;被提升到了第一行，a=2则原地等待
```
不仅仅如此,对于函数而言也是一样的:
```
foo();
function foo(){
  console.log(a);//undefined
  var a=2;
}
```
这里做了2次变量提升，一次是foo()，而另一处是foo()内部的var a;，不过a输出的是undefined.它和下面代码是等价的
```
function foo(){
  var a;
  console.log(a)
  a=2;
}
foo()
```
继续看例子:
```
foo()
var foo=function bar(){

}
```
这个时候会输出一个错误信息:**foo不是函数**.这样是因为函数申明会被提升，而函数表达式并不会。
上面的代码,和一下代码是等价的
```
var foo;
foo()
foo=function var(){
}
```
